<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>LumaAI, thre.js and WebGl</title>
        
    </head>
    <body>
        <canvas></canvas>
        <canvas></canvas>
        <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
                "@lumaai/luma-web": "https://unpkg.com/@lumaai/luma-web@0.2.0/dist/library/luma-web.module.js"
            }
        }
        </script>
        <script type="module">
        import { WebGLRenderer, PerspectiveCamera, Scene } from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { LumaSplatsThree } from '@lumaai/luma-web';
        import {VRButton} from '/libs/VRButton.js';
        import{XRControllerModelFactory} from '/libs/XRControllerModelFactory.js';
        
        let canvas = document.querySelector('canvas');
        
        let renderer = new WebGLRenderer({
            canvas: canvas,
            antialias: false
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        
        let scene = new Scene();
        
        let camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2;
        
        let controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        
        let splat = new LumaSplatsThree({
            source: 'https://lumalabs.ai/capture/d80d4876-cf71-4b8a-8b5b-49ffac44cd4a'
            //source: 'https://lumalabs.ai/capture/f483342e-afa1-4445-a5d3-930c1ff7e068'
        });
        
function createVRControllers(){
 
 function onSelectStart() {
   this.children[0].scale.z = 10;
   this.userData.isSelecting = true; 
 }
 function onSelectEnd() {
   this.children[0].scale.z = 0;
   this.userData.isSelecting = false;
 }  
 //set up controller 1 
  controller1 = renderer.xr.getController( 0 );
  controller1.addEventListener( 'selectstart', onSelectStart );
  controller1.addEventListener( 'selectend', onSelectEnd );
  controller1.addEventListener( 'connected', function ( event ) {
    this.add( buildController( event.data ) );
  });
  controller1.addEventListener( 'disconnected', function () { this.remove( this.children[ 0 ] ); } );
  scene.add( controller1 );

  //set up controller 2
  controller2 = renderer.xr.getController( 1 );
  controller2.addEventListener( 'selectstart', onSelectStart );
  controller2.addEventListener( 'selectend', onSelectEnd );
  controller2.addEventListener( 'connected', function ( event ) {
    this.add( buildController( event.data ) );
  });
  controller2.addEventListener( 'disconnected', function () { this.remove( this.children[ 0 ] ); } );
  scene.add( controller2 );

  const controllerModelFactory = new XRControllerModelFactory();
  controllerGrip1 = renderer.xr.getControllerGrip( 0 );
  controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
  scene.add( controllerGrip1 );

  controllerGrip2 = renderer.xr.getControllerGrip( 1 );
  controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
  scene.add( controllerGrip2 );
  window.addEventListener( 'resize', onWindowResize, false );

  function buildController( data ) {
   let geometry, material;
   switch ( data.targetRayMode ) {
     case 'tracked-pointer':
       geometry = new THREE.BufferGeometry();
       geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
       geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );
       material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );
       return new THREE.Line( geometry, material );
     case 'gaze':
       geometry = new THREE.RingBufferGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
       material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
       return new THREE.Mesh( geometry, material );
     }
   }
 }
        scene.add(splat);
        
        renderer.setAnimationLoop(() => {
            controls.update();
            renderer.render(scene, camera);
        });
        </script>
    </body>
</html>
